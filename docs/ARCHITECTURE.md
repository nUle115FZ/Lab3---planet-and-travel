# Архитектура проекта "Космическая Логистика"

## 📊 Диаграмма классов (упрощенная)

```
┌─────────────────────────────────────────────────────────────────┐
│                        БАЗОВЫЕ СТРУКТУРЫ                        │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────────┐
    │  Sequence<T>     │  ◄─── Абстрактный интерфейс
    │  (abstract)      │
    │                  │
    │ + Get()          │
    │ + GetSize()      │
    │ + Append()       │
    │ + Prepend()      │
    │ + InsertAt()     │
    │ + RemoveAt()     │
    └────────┬─────────┘
             │
             │ наследует
             ▼
    ┌──────────────────┐
    │  DynamicArray<T> │  ◄─── Реализация на массиве
    │                  │
    │ - data: T*       │
    │ - size: int      │
    │ - capacity: int  │
    │                  │
    │ + operator[]     │
    │ - resize()       │
    └────────┬─────────┘
             │
             │ приватное наследование
             ▼
    ┌─────────────────────────┐
    │  PriorityQueue<T, K>    │  ◄─── Min-heap реализация
    │                         │
    │ - comparator            │
    │                         │
    │ + Enqueue(item, prior)  │
    │ + Dequeue() → T         │
    │ + Peek() → T            │
    │ + IsEmpty() → bool      │
    │ - heapifyUp()           │
    │ - heapifyDown()         │
    └─────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        ГРАФОВЫЕ СТРУКТУРЫ                       │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────────┐
    │   EdgeWeight     │  ◄─── Вес ребра
    │                  │
    │ + distance       │
    │ + riskFactor     │
    │ + getTotalCost() │
    └──────────────────┘
             │
             │ использует
             ▼
    ┌──────────────────┐
    │      Edge        │  ◄─── Ребро графа
    │                  │
    │ + to: int        │
    │ + weight         │
    └──────────────────┘
             │
             │ использует
             ▼
    ┌─────────────────────────────────┐
    │         StarGraph               │  ◄─── Ориентированный граф
    │                                 │
    │ - adjacencyList                 │       (список смежности)
    │ - planetNames                   │
    │ - nameToIndex                   │
    │                                 │
    │ + AddVertex(name) → int         │
    │ + AddEdge(from, to, weight)     │
    │ + GetEdges(vertex)              │
    │ + GetVertexCount() → int        │
    │ + HasVertex(id) → bool          │
    └─────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                          АЛГОРИТМЫ                              │
└─────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────┐
    │           Dijkstra                  │  ◄─── Алгоритм Дейкстры
    │                                     │
    │ - graph: StarGraph&                 │
    │                                     │
    │ + FindShortestPath(start, end)      │
    │     → DijkstraResult                │
    │ + FindAllShortestPaths(start)       │
    │     → map<int, double>              │
    │ - reconstructPath()                 │
    └─────────────────────────────────────┘
             │
             │ использует
             ▼
    ┌─────────────────────────────────────┐
    │       DijkstraResult                │  ◄─── Результат поиска
    │                                     │
    │ + pathExists: bool                  │
    │ + totalCost: double                 │
    │ + path: DynamicArray<int>           │
    │ + pathNames: DynamicArray<string>   │
    └─────────────────────────────────────┘

    ┌─────────────────────────────────────┐
    │          Analytics                  │  ◄─── Тестирование
    │                                     │
    │ + measurePerformance()              │
    │ + runPerformanceTests()             │
    │ + exportToCSV()                     │
    │ + generateDemoGraph()               │
    │ + generateRandomGraph()             │
    └─────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        Qt ИНТЕРФЕЙС                             │
└─────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────┐
    │         MainWindow                  │  ◄─── Главное окно
    │         (QMainWindow)               │
    │                                     │
    │ - graph: StarGraph                  │
    │ - graphView: GraphView*             │
    │                                     │
    │ + onAddPlanet()                     │
    │ + onAddEdge()                       │
    │ + onFindPath()                      │
    │ + onLoadDemo()                      │
    │ + onRunPerformanceTest()            │
    └─────────────────────────────────────┘
             │
             │ содержит
             ▼
    ┌─────────────────────────────────────┐
    │         GraphView                   │  ◄─── Визуализация
    │         (QWidget)                   │
    │                                     │
    │ - graph: StarGraph*                 │
    │ - nodePositions: QMap               │
    │ - highlightedPath                   │
    │                                     │
    │ + paintEvent()                      │
    │ + mousePressEvent()                 │
    │ + mouseMoveEvent()                  │
    │ + highlightPath()                   │
    │ - drawNode()                        │
    │ - drawEdge()                        │
    └─────────────────────────────────────┘

    ┌──────────────────────┐  ┌──────────────────────┐
    │  AddPlanetDialog     │  │  AddEdgeDialog       │
    │  (QDialog)           │  │  (QDialog)           │
    │                      │  │                      │
    │ + getPlanetName()    │  │ + getFromPlanet()    │
    └──────────────────────┘  │ + getToPlanet()      │
                              │ + getDistance()      │
                              │ + getRisk()          │
                              └──────────────────────┘
```

## 🔄 Поток работы алгоритма Дейкстры

```
1. Инициализация
   ├─ Создать карту расстояний (все ∞, кроме start = 0)
   ├─ Создать карту предшественников (пустая)
   └─ Создать PriorityQueue

2. Добавить start в очередь с приоритетом 0

3. Пока очередь не пуста:
   ├─ Извлечь вершину с минимальным расстоянием
   │
   ├─ Если вершина уже посещена → пропустить
   │
   ├─ Пометить вершину как посещенную
   │
   ├─ Для каждого соседа:
   │  ├─ Вычислить новое расстояние
   │  ├─ Если новое расстояние < текущего:
   │  │  ├─ Обновить расстояние
   │  │  ├─ Обновить предшественника
   │  │  └─ Добавить соседа в очередь
   │  └─
   └─

4. Восстановить путь из предшественников

5. Вернуть DijkstraResult
```

## 💾 Структура данных графа

```
StarGraph {
    adjacencyList: map<int, DynamicArray<Edge>>
    
    Пример:
    0 (Терра) → [(1, w=50), (2, w=150)]
    1 (Марс)  → [(2, w=100)]
    2 (Юпитер)→ [(3, w=120)]
    3 (Сатурн)→ []
}

Визуализация:
    Терра ──50──→ Марс
      │            │
     150         100
      │            │
      └──→ Юпитер ──120──→ Сатурн
```

## ⚡ Сложности операций

| Операция | DynamicArray | PriorityQueue | StarGraph |
|----------|--------------|---------------|-----------|
| Append   | O(1) амор.   | -             | -         |
| Get      | O(1)         | -             | -         |
| Enqueue  | -            | O(log n)      | -         |
| Dequeue  | -            | O(log n)      | -         |
| AddVertex| -            | -             | O(1)      |
| AddEdge  | -            | -             | O(1)      |
| GetEdges | -            | -             | O(1)      |
| Dijkstra | -            | -             | O((V+E)log V) |

## 🎯 Ключевые особенности реализации

### 1. Приватное наследование PriorityQueue
```cpp
class PriorityQueue : private DynamicArray<pair<T, K>>
```
- Скрывает методы Sequence (Append, Prepend и т.д.)
- Оставляет только интерфейс очереди

### 2. Min-Heap реализация
```cpp
parent(i) = (i - 1) / 2
leftChild(i) = 2 * i + 1
rightChild(i) = 2 * i + 2
```

### 3. Формула стоимости перехода
```cpp
totalCost = distance × (1 + riskFactor)
```
- distance: 50, risk: 0.2 → cost = 50 × 1.2 = 60
- distance: 100, risk: 0.5 → cost = 100 × 1.5 = 150

### 4. Список смежности
Эффективен для разреженных графов:
- Память: O(V + E) вместо O(V²)
- Обход соседей: O(степень вершины)

## 📈 Оценка производительности

Для графа с V вершинами и E ребрами:

**Алгоритм Дейкстры:**
- Время: O((V + E) log V)
- Память: O(V)

**Почему log V?**
- Каждая вершина добавляется в PriorityQueue: O(log V)
- Может быть добавлена несколько раз: O(E) раз
- Итого: O(E log V)

**Пример расчета:**
- V = 100, E = 300
- Время ≈ (100 + 300) × log₂(100) ≈ 400 × 7 ≈ 2800 операций

## 🎨 Визуализация

### Цветовая схема
- **Планеты**: Синий градиент (обычные), золотой (подсвеченные)
- **Переходы**: Зеленый → Красный (риск 0.0 → 1.0)
- **Путь**: Золотой с толстой линией
- **Фон**: Темный космический градиент

### Интерактивность
- Drag & Drop узлов
- Hover эффекты
- Лог действий в реальном времени

## 📝 Контрольные вопросы

1. **Почему используется PriorityQueue вместо обычной очереди?**
   → Для эффективного выбора вершины с минимальным расстоянием

2. **Что произойдет, если граф содержит цикл?**
   → Алгоритм корректно работает, так как вершины помечаются как посещенные

3. **Можно ли использовать Дейкстру для отрицательных весов?**
   → Нет! Для отрицательных весов используется Беллман-Форд

4. **Почему граф ориентированный?**
   → Гиперпространственные переходы могут быть односторонними

5. **Как добавить поддержку неориентированного графа?**
   → Добавлять два ребра (туда и обратно) для каждого перехода

---

**Эта шпаргалка содержит все ключевые моменты для защиты ЛР!** 📚

